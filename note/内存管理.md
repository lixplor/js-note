# 内存管理

JS在变量创建时分配内存, 在不再使用时进行垃圾回收

## 内存生命周期

* 大致逻辑
    - 分配需要的内存
    - 使用分配的内存
    - 不需要时释放内存

### JS的内存分配

* 在初始化时分配内存
* 调用函数分配内存

```javascript
// 给数字变量分配内存
var n = 123;

// 给字符串分配内存
var s = "adsf";

// 给对象及其属性分配内存
var o = {
    a:1,
    b:null
};

// 给数组及其元素分配内存 (和对象类似)
var a = [1, null, "adf"];

// 给函数分配内存 (函数是Function对象)
function f(a) {
    return a + 2;
}

// 函数表达式分配对象
someElement.addEventListener("click", function(){
    someElement.style.backgroundColor = "blue";
}, false);


// 调用函数分配内存
var d = new Date(); // 分配一个Date对象
var e = document.createElement("div"); // 分配一个DOM元素
```

### 内存的使用

* 使用值的过程, 实际上是对分配内存进行读写的操作

### 内存的释放

* 当所分配的内存不再被使用
* 垃圾回收器的工作是跟踪内存的分配和使用, 当内存不再使用时, 释放内存

## 垃圾回收

* `引用`
    - 垃圾回收算法主要依赖于引用
    - 如果一个对象有访问另一个对象的权限(隐式或者显式), 叫做一个对象引用另一个对象
        - 例如, 一个JS对象具有对他原型的引用(隐式引用)和对他属性的引用(显示引用)
* 垃圾收集算法
    - `引用计数`: 最简单的垃圾回收算法, 如果指向该对象的引用数为0, 则回收该对象
        - 缺点: 无法处理循环引用的对象
    - `标记清除`算法: 设置一个root根对象, 垃圾回收器定期从root开始查找所有引用, 找不到的对象就是需要回收的


```javascript
// 创建了o和a两个对象, o引用了a对象
var o = {
    a:{
        b:2
    }
};
// o2变量是第二个对o对象的引用
var o2 = o;
// 将o对象的引用指向1, 此时只有o2指向以前的o对象
o = 1;
// 引用"那个对象"的属性a, 现在"那个对象"又多了一个oa引用
var oa = o2.a;
// 将o2指向字符串引用, 此时只有oa引用着"那个对象"的a属性, 所以还是不能回收
o2 = "yo";
// 取消oa的引用, 现在"那个对象"没有任何引用, 可以等待GC
oa = null;
```

### 循环引用

* 两个对象互相引用
